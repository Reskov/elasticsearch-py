import functools
import textwrap

import perf

IMPLEMENTATIONS = {
    "old": """\
    from elasticsearch.client.utils import query_params
    """,
    "new": """\
    from elasticsearch.client.utils import _escape
    from functools import wraps

    GLOBAL_PARAMS = {'pretty', 'human', 'error_trace', 'format', 'filter_path'}

    def query_params(*es_query_params):
        all_params = set(es_query_params) | GLOBAL_PARAMS

        def _wrapper(func):
            @wraps(func)
            def _wrapped(*args, **kwargs):
                params = kwargs.pop('params', {}).copy()

                for p in kwargs.keys() & all_params:
                    v = kwargs.pop(p)
                    if v is not None:
                        params[p] = _escape(v)

                # don't treat ignore and request_timeout as other params to avoid escaping
                for p in ('ignore', 'request_timeout'):
                    if p in kwargs:
                        params[p] = kwargs.pop(p)
                return func(*args, params=params, **kwargs)
            return _wrapped
        return _wrapper

    """,
}

INIT = """\
all_params = {'pre_filter_shard_size', 'suggest_text', 'suggest_field', 'expand_wildcards', 'track_scores', 'format', 'terminate_after', 'allow_no_indices', 'ignore_unavailable', 'human', 'allow_partial_search_results', 'scroll', '_source', 'typed_keys', 'request_cache', 'max_concurrent_shard_requests', 'stats', 'default_operator', 'stored_fields', 'search_type', 'from_', 'size', 'analyze_wildcard', 'timeout', 'track_total_hits', '_source_include', 'docvalue_fields', 'version', 'explain', 'error_trace', 'filter_path', '_source_exclude', 'q', 'routing', 'analyzer', 'preference', 'suggest_mode', 'pretty', 'suggest_size', 'sort', 'df', 'batched_reduce_size', 'lenient'}
func = query_params(*all_params)(lambda x, params:params)
"""

RUN_QUERY_PARAMS = """\
func(1)
func(1)
func(1)
func(1)
func(1)
func(1)
func(1)
func(1)
func(1)
func(1)
func(1)
func(1)
"""


def benchmark_name(name, ctx, prefix=None, use_prefix=False):
    if use_prefix:
        return "%s%s" % (prefix % ctx, name)

    return name


def add_impl_option(cmd, args):
    if args.impl:
        cmd.extend(["--impl", args.impl])


if __name__ == "__main__":
    runner = perf.Runner(add_cmdline_args=add_impl_option)

    parser = runner.argparser
    parser.description = "Allows to measure performance of " " implementations"
    parser.add_argument(
        "--impl",
        choices=sorted(IMPLEMENTATIONS),
        help="specific implementation to benchmark",
    )

    options = parser.parse_args()
    implementations = (options.impl,) if options.impl else IMPLEMENTATIONS

    for name in implementations:
        imports = textwrap.dedent(IMPLEMENTATIONS[name])
        name = functools.partial(
            benchmark_name,
            ctx=dict(impl=name),
            prefix="(impl = %(impl)s) ",
            use_prefix=len(implementations) > 1,
        )

        runner.timeit(name("query_params->query_params"), RUN_QUERY_PARAMS, imports + INIT, inner_loops=10)
